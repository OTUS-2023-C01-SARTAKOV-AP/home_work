// анализ файлов на предмет наличия в них заархивированных данных
// файл указывается через окно терминала (указанием ссылки на требуемый файл)
// Все переменные на русском языке
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <stdint.h>
#include "header.h"


int main(int argc, char *argv[])
{
    #define MAX_символов 1024 // при использовании русских букв они считаются по 2 байта!
    FILE *наш_файл;
    unsigned char символ;
    int длина_файла;
    register unsigned long int цикл;    
    bool скрытый_архив=false;
    char полный_путь_кфайлу[MAX_символов] = "";
    int длина_строки =0;

    union 
    {
        unsigned char символ; // когда у нас сработает числовая комбинация, то этот символ будет равен 0b 0100 1111 = O 
                // (большая заглавная О в английском алфавите = 79 в десятичном исчеслении в ASCII
        struct 
        {
            uint8_t бит_0 :1; // это самый младший бит в байте (нумерация наоборот) 
            uint8_t бит_1 :1; 
            uint8_t бит_2 :1; 
            uint8_t бит_3 :1; 
            uint8_t бит_4 :1; // это пустышка (4 старших бита
            uint8_t бит_5 :1; // это пустышка (4 старших бита
            uint8_t бит_6 :1; // это пустышка (4 старших бита
            uint8_t бит_7 :1; // это пустышка (4 старших бита
            
        } биты;
    } бит_символ;
    
    бит_символ.биты.бит_0 = 0; 
    бит_символ.биты.бит_1 = 0;
    бит_символ.биты.бит_2 = 0;
    бит_символ.биты.бит_3 = 0;
    бит_символ.биты.бит_4 = 0;
    бит_символ.биты.бит_5 = 0; 
    бит_символ.биты.бит_6 = 1;
    бит_символ.биты.бит_7 = 0; // в итоге должно получится 0b0100 0000 = @ как шестнадцатиричный = 0х40 и как десятичный = 64 


    // ЧАСТЬ 1 . Прием имя файла, каталога из консоли.
    // Размер файла ограничен signed 2^32, что равно 1/2 от 4,3 млд = 2,15 млрд символов = 2,1 Гб данныхсимвол
    // проверка программы на количество вводимых аргументов
    if (argc !=3) 
    {        
        // указание что делать, нехватает аргументов при открытии файла
        помощь_откр_файла(); 
    }
    
    if (strncmp(argv[1], "-here", 6) == 0 ) // сработал ключ = "-here"
    {
        if ((наш_файл=fopen(argv[2], "rb")) == NULL)
        {
            perror(argv[2]);
            return 1;
        }
    }
    else
    {
        // сшиваем путь к папке и имя файла в одну строку с проверкой на переполнение
        strncat(полный_путь_кфайлу, argv[1], MAX_символов-1);
        длина_строки = strlen(полный_путь_кфайлу); 
        strncat(полный_путь_кфайлу, argv[2], MAX_символов - длина_строки - 1);
        printf("Полная длина пути к исполняемому файлу = %d символов. \n", (int) strlen(полный_путь_кфайлу));
        
        if ((наш_файл=fopen(полный_путь_кфайлу, "rb")) == NULL)
        {
            perror(argv[1]);
            perror(argv[2]);
            return 1;
        }
    }
    
    
    // Определяет - есть ли внутри картинки zip архивы 
    fseek(наш_файл, 0L, SEEK_END);
    длина_файла = ftell(наш_файл);
    for (цикл = 1L; цикл <= длина_файла; цикл++) 
    {
        fseek(наш_файл, -цикл, SEEK_END); // считываем побайтно данные с КОНЦА файла
        символ = getc(наш_файл);
        // если ни один из символов не входит в ключ, то овновляет ключ
        if ((символ != 0x02) and (символ != 0x01) and (символ != 0x4b) and (символ != 0x50))
        {
            бит_символ.символ = '@';
        }
        else
        {
            switch (символ)
            {
                case 0x02: // это у нас самый последний байт из 4, ставим самый младший бит (_0) 1
                    бит_символ.биты.бит_0 = 1;
                    break;
                case 0x01: 
                    бит_символ.биты.бит_1 = 1;
                    break;
                case 0x4b: 
                    бит_символ.биты.бит_2 = 1;
                    break;
                case 0x50: // это у нас самый первый байт из 4-х если идти он начала файла, ставим ему 1 (бит_3)
                    бит_символ.биты.бит_3 = 1;
            }
            if (бит_символ.символ == 'O') // смотри параметры переменной
            {
                printf("\nВ вашем изображении есть скрытые файлы, то есть о является Rarjpeg-ом  архивом \n");   
                
                // запускаем функцию по поиску и выводу названий файлов внутри картинки
                fseek(наш_файл, (-1L+28L), SEEK_CUR); // считываем длину имени файла
                символ = getc(наш_файл);
                printf("Длина имени файла десятич=%d символов \nЕго название:  ", символ);
                
                fseek(наш_файл, (-1L+18L), SEEK_CUR); // здесь первый символ названия файла
                for (int i=0; i < (int) символ; i++)
                {
                    printf("%c",getc(наш_файл)); // автоматически смещается на 1 позицию к концу файла!
                }
                
                printf("\n");
                бит_символ.символ = '@';
                скрытый_архив = true;
            }
        }
    }

    if (скрытый_архив == false)
    {
        puts("Ваш файл НЕ является Rarjpeg-ом  архивом \n");
    }
    
    printf("При работе программа обработала байт = %lu \n", цикл);
	return 0;
    
}


